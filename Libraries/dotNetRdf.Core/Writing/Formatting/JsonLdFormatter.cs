/*
// <copyright>
// dotNetRDF is free and open source software licensed under the MIT License
// -------------------------------------------------------------------------
// 
// Copyright (c) 2009-2023 dotNetRDF Project (http://dotnetrdf.org/)
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is furnished
// to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// </copyright>
*/

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Text.RegularExpressions;
using System.Xml;
using VDS.RDF.JsonLd.Syntax;
using VDS.RDF.Parsing;

namespace VDS.RDF.Writing.Formatting
{
    /// <summary>
    /// A formatter which formats triples for JSON-LD output.
    /// </summary>
    public class JsonLdFormatter 
        : IGraphFormatter, INodeFormatter, IUriFormatter, IQuadFormatter
    {
        private readonly JsonLdWriterOptions _options;
        
        /// <summary>
        /// If the this flag is set to true, RDF literals with a datatype IRI that equals xsd:integer or xsd:double are converted 
        /// to a JSON numbers and RDF literals with a datatype IRI that equals xsd:boolean are converted to true or false based 
        /// on their lexical form.
        /// </summary>
        public bool UseNativeTypes { get => _options.UseNativeTypes; set => _options.UseNativeTypes = value; }

        /// <summary>
        /// Unless this flag is set to true, rdf:type predicates will be serialized as @type as long as the 
        /// associated object is either an IRI or blank node identifier.
        /// </summary>
        public bool UseRdfType { get => _options.UseRdfType; set => _options.UseRdfType = value; }

        /// <summary>
        /// Get or set the default processing mode for the writer.
        /// </summary>
        public JsonLdProcessingMode ProcessingMode { get => _options.ProcessingMode; set => _options.ProcessingMode = value; }

        /// <summary>
        /// Get or set the formatting to apply to the JSON generated by the writer.
        /// </summary>
        /// <remarks>Defaults to <see cref="Newtonsoft.Json.Formatting.Indented"/>.</remarks>
        public Newtonsoft.Json.Formatting JsonFormatting { get => _options.JsonFormatting; set => _options.JsonFormatting = value; }

        /// <summary>
        /// Create a new formatter with default formatting options.
        /// </summary>
        public JsonLdFormatter()
        {
            _options = new JsonLdWriterOptions();
        }

        /// <summary>
        /// Create a new formatter with the specified formatting options.
        /// </summary>
        /// <param name="options"></param>
        public JsonLdFormatter(JsonLdWriterOptions options)
        {
            _options = options;
        }

        /// <summary>
        /// Formats a Graph Header by starting a JSON object with <strong>[</strong>.
        /// </summary>
        /// <param name="g">Graph.</param>
        /// <returns></returns>
        public virtual string FormatGraphHeader(IGraph g)
        {
            return FormatGraphHeader();
        }

        /// <summary>
        /// Formats a Graph Header by starting a JSON object with <strong>[</strong>.
        /// </summary>
        /// <param name="namespaces">Namespaces.</param>
        /// <param name="uriFactory">The factory to use when creating new Uri instances.</param>
        /// <returns></returns>
        public virtual string FormatGraphHeader(INamespaceMapper namespaces, IUriFactory uriFactory = null)
        {
            return FormatGraphHeader();
        }

        /// <summary>
        /// Formats a Graph Header by starting a JSON array with <strong>[</strong>.
        /// </summary>
        public virtual string FormatGraphHeader()
        {
            return "[";
        }

        /// <summary>
        /// Formats a Graph Footer by closing the JSON array with <strong>{}]</strong> in case of a preceding comma.
        /// </summary>
        /// <returns></returns>
        public virtual string FormatGraphFooter()
        {
            return "{}]";
        }

        /// <summary>
        /// Formats a Triple as a JSON object.
        /// </summary>
        /// <param name="t">Triple.</param>
        /// <returns></returns>
        public virtual string Format(Triple t)
        {
            return FormatAsJObject(t).ToString(JsonFormatting) + ",";
        }

        /// <summary>
        /// Formats a Triple as a JSON object.
        /// </summary>
        /// <param name="t">Triple.</param>
        /// <param name="graph">Graph.</param>
        /// <returns></returns>
        public virtual string Format(Triple t, IRefNode graph)
        {
            var node = FormatAsJObject(t);
            if (graph != null)
            {
                var graphNode = FormatAsJObject(graph);
                graphNode["@graph"] = node;
                node = graphNode;
            }
            return node.ToString(JsonFormatting) + ",";
        }

        /// <summary>
        /// Formats a Triple as a JSON object.
        /// </summary>
        /// <param name="t">Triple.</param>
        /// <returns></returns>
        public virtual JObject FormatAsJObject(Triple t)
        {
            var subject = MakeNodeString(t.Subject);
            var predicate = MakeNodeString(t.Predicate);
            var @object = t.Object is IUriNode || t.Object is IBlankNode ? MakeNodeString(t.Object) : null;

            var node = new JObject(new JProperty("@id", subject));

            // 5.7.5 - If predicate equals rdf:type, the useRdfType flag is not true, and object is an IRI or blank node identifier
            if (predicate.Equals(RdfSpecsHelper.RdfType) && !_options.UseRdfType &&
                (t.Object is IUriNode || t.Object is IBlankNode))
            {
                // Set the object to the value of the @type entry
                node.Add("@type", @object);

                // Finally, continue to the next triple.
                return node;
            }

            // 5.7.6 - Initialize value to the result of using the RDF to Object Conversion algorithm, passing object, rdfDirection, and useNativeTypes.
            JToken value = FormatAsJObject(t.Object);

            if (value is JObject { Count: 1 } valueObject && valueObject.TryGetValue("@value", out var innerValue))
            {
                // It is just the value, no need for object
                value = innerValue;
            }

            // Set the reference to value of the property.
            node[predicate] = value;
            return node;
        }

        /// <summary>
        /// Gets the String value of a Node.
        /// </summary>
        /// <param name="u">Node.</param>
        /// <returns></returns>
        public virtual string MakeNodeString(INode n)
        {
            return n switch
            {
                IUriNode uriNode => uriNode.Uri.OriginalString,
                IBlankNode blankNode => "_:" + blankNode.InternalID,
                _ => throw new ArgumentException("Node must be a blank node or URI node", nameof(n))
            };
        }

        /// <summary>
        /// Formats a Node as a JSON object.
        /// </summary>
        /// <param name="n">Node.</param>
        /// <returns></returns>
        public virtual string Format(INode n)
        {
            return Format(n, null);
        }

        /// <summary>
        /// Formats a Node as a JSON object.
        /// </summary>
        /// <param name="n">Node.</param>
        /// <param name="segment">Triple Segment.</param>
        /// <returns></returns>
        public virtual string Format(INode n, TripleSegment? segment)
        {
            return FormatAsJObject(n).ToString(JsonFormatting);
        }

        /// <summary>
        /// Formats a Node as a JSON object.
        /// </summary>
        /// <param name="n">Node.</param>
        /// <returns></returns>
        public virtual JObject FormatAsJObject(INode n)
        {
            switch (n)
            {
                // 1 - If value is an IRI or a blank node identifier, return a new dictionary consisting of a single member @id whose value is set to value.
                case IUriNode uriNode:
                    return new JObject(new JProperty("@id", uriNode.Uri.OriginalString));
                case IBlankNode bNode:
                    return new JObject(new JProperty("@id", "_:" + bNode.InternalID));
                case ILiteralNode literal:
                    // 2 - Otherwise value is an RDF literal:
                    // 2.1 - Initialize a new empty dictionary result.
                    var result = new JObject();
                    // 2.2 - Initialize converted value to value.
                    JToken convertedValue = new JValue(literal.Value);
                    // 2.3 - Initialize type to null
                    string type = null;
                    // 2.4 - If use native types is true
                    if (_options.UseNativeTypes && literal.DataType != null)
                    {
                        switch (literal.DataType.ToString())
                        {
                            // 2.4.1 - If the datatype IRI of value equals xsd:string, set converted value to the lexical form of value.
                            case XmlSpecsHelper.XmlSchemaDataTypeString:
                                convertedValue = new JValue(literal.Value);
                                break;

                            // 2.4.2 - Otherwise, if the datatype IRI of value equals xsd:boolean, set converted value to true if the lexical form of value matches true, or false if it matches false. If it matches neither, set type to xsd:boolean.
                            case XmlSpecsHelper.XmlSchemaDataTypeBoolean:
                                if (literal.Value.Equals("true"))
                                {
                                    convertedValue = new JValue(true);
                                }
                                else if (literal.Value.Equals("false"))
                                {
                                    convertedValue = new JValue(false);
                                }
                                else
                                {
                                    goto default;
                                }
                                break;

                            // 2.4.3 - Otherwise, if the datatype IRI of value equals xsd:integer or xsd:double and its lexical form is a valid xsd:integer or xsd:double according [XMLSCHEMA11-2], set converted value to the result of converting the lexical form to a JSON number.
                            case XmlSpecsHelper.XmlSchemaDataTypeInteger:
                                if (IsWellFormedInteger(literal.Value))
                                {
                                    convertedValue = new JValue(XmlConvert.ToInt64(literal.Value));
                                }
                                else
                                {
                                    goto default;
                                }
                                break;
                            case XmlSpecsHelper.XmlSchemaDataTypeDouble:
                                if (IsWellFormedDouble(literal.Value))
                                {
                                    convertedValue = new JValue(XmlConvert.ToDouble(literal.Value));
                                }
                                else
                                {
                                    goto default;
                                }
                                break;

                            // KA: Step missing from spec - otherwise set type to the datatype IRI
                            default:
                                type = literal.DataType.ToString();
                                break;
                        }
                    }
                    // 2.5 - Otherwise, if processing mode is not json-ld-1.0, and value is a JSON literal, set converted value to the result of turning the lexical value of value into the JSON-LD internal representation, and set type to @json. If the lexical value of value is not valid JSON according to the JSON Grammar [RFC8259], an invalid JSON literal error has been detected and processing is aborted.
                    else if (_options.ProcessingMode != JsonLdProcessingMode.JsonLd10 &&
                             RdfSpecsHelper.RdfJson.Equals(literal.DataType?.ToString()))
                    {
                        try
                        {
                            convertedValue = JToken.Parse(literal.Value);
                            type = "@json";
                        }
                        catch
                        {
                            type = RdfSpecsHelper.RdfJson;
                        }
                    }
                    // 2.6 - Otherwise, if the datatype IRI of value starts with https://www.w3.org/ns/i18n#, and rdfDirection is i18n-datatype:
                    else if (_options.RdfDirection == JsonLdRdfDirectionMode.I18NDatatype && literal.DataType != null &&
                             literal.DataType.ToString().StartsWith("https://www.w3.org/ns/i18n#"))
                    {
                        var fragment = literal.DataType.Fragment.TrimStart('#');
                        if (!string.IsNullOrEmpty(literal.DataType.Fragment) && fragment.Contains("_"))
                        {
                            convertedValue = literal.Value;
                            var sepIx = fragment.IndexOf("_", StringComparison.Ordinal);
                            if (sepIx > 0)
                            {
                                result["@language"] = fragment.Substring(0, sepIx);
                            }
                            result["@direction"] = fragment.Substring(sepIx + 1);
                        }
                        else
                        {
                            type = literal.DataType.ToString();
                        }
                    }
                    // 2.7 - Otherwise, if value is a language-tagged string add a member @language to result and set its value to the language tag of value.
                    else if (!string.IsNullOrEmpty(literal.Language))
                    {
                        result["@language"] = literal.Language;
                    }
                    // 2.8 - Otherwise, set type to the datatype IRI of value, unless it equals xsd:string which is ignored.
                    else
                    {
                        if (literal.DataType != null && !literal.DataType.ToString()
                                .Equals(XmlSpecsHelper.XmlSchemaDataTypeString))
                        {
                            type = literal.DataType.ToString();
                        }
                    }
                    // 2.9 - Add a member @value to result whose value is set to converted value.
                    result["@value"] = convertedValue;
                    // 2.10 - If type is not null, add a member @type to result whose value is set to type.
                    if (type != null) result["@type"] = type;
                    // 2.11 - Return result.
                    return result;
            }

            return null;
        }

        private static readonly Regex IntegerLexicalRepresentation = new Regex(@"^(\+|\-)?\d+$");

        private static bool IsWellFormedInteger(string literal)
        {
            return IntegerLexicalRepresentation.IsMatch(literal);
        }

        private static readonly Regex DoubleLexicalRepresentation = new Regex(@"^((\+|-)?([0-9]+(\.[0-9]*)?|\.[0-9]+)([Ee](\+|-)?[0-9]+)?|(\+|-)?INF|NaN)$");

        private static bool IsWellFormedDouble(string literal)
        {
            return DoubleLexicalRepresentation.IsMatch(literal);
        }

        /// <summary>
        /// Formats a URI as a String.
        /// </summary>
        /// <param name="u">URI.</param>
        /// <returns></returns>
        public virtual string FormatUri(Uri u)
        {
            return FormatUri(u.AbsoluteUri);
        }

        /// <summary>
        /// Formats a URI as a String.
        /// </summary>
        /// <param name="u">URI.</param>
        /// <returns></returns>
        public virtual string FormatUri(string u)
        {
            return JsonConvert.ToString(u);
        }

        /// <summary>
        /// Gets the String description of this formatter.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "JSON-LD";
        }
    }
}
