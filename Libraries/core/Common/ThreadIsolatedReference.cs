/*

Copyright dotNetRDF Project 2009-12
dotnetrdf-develop@lists.sf.net

------------------------------------------------------------------------

This file is part of dotNetRDF.

dotNetRDF is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

dotNetRDF is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with dotNetRDF.  If not, see <http://www.gnu.org/licenses/>.

------------------------------------------------------------------------

dotNetRDF may alternatively be used under the LGPL or MIT License

http://www.gnu.org/licenses/lgpl.html
http://www.opensource.org/licenses/mit-license.php

If these licenses are not suitable for your intended use please contact
us at the above stated email address to discuss alternative
terms.

*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;

namespace VDS.Common
{
    /// <summary>
    /// Provides a thread isolated reference to some reference type
    /// </summary>
    /// <typeparam name="T">Reference Type</typeparam>
    /// <remarks>
    /// <para>
    /// Essentially the ThreadIsolatedReference guarantees that each thread that accesses it sees a thread-specific view of the reference.  The initial value of the reference for each Thread is generated either by an initialiser function passed to the constructor when the ThreadSafeReference is created or otherwise is null.  This is essentially what the <see cref="ThreadLocal"/> introduced in .Net 4.0 does but we continue to use this our own wrapper because we need backwards compatibility with .Net 3.5 and ThreadLocal does not play quite right with some of our usage patterns
    /// </para>
    /// </remarks>
    class ThreadIsolatedReference<T> 
        : IDisposable
        where T : class
    {
        private Dictionary<int, T> _refs = new Dictionary<int, T>();
        private Func<T> _init;

        /// <summary>
        /// Creates a new ThreadSafeReference where the initial value of the reference on each thread is null
        /// </summary>
        public ThreadIsolatedReference()
        { }

        /// <summary>
        /// Creates a new ThreadSafeReference where the initial value of the reference on each thread is generated by the given initialiser function
        /// </summary>
        /// <param name="init">Initialiser Function</param>
        public ThreadIsolatedReference(Func<T> init)
        {
            this._init = init;
        }

        /// <summary>
        /// Gets the initialiser function
        /// </summary>
        public Func<T> Initialiser
        {
            get
            {
                return this._init;
            }
        }

        /// <summary>
        /// Gets/Sets the value for the current thread
        /// </summary>
        public T Value
        {
            get
            {
                try
                {
                    Monitor.Enter(this._refs);
                    int id = Thread.CurrentThread.ManagedThreadId;
                    if (!this._refs.ContainsKey(id))
                    {
                        this._refs.Add(id, null);
                        if (this._init != null)
                        {
                            this._refs[id] = this._init();
                        }
                    }
                    return this._refs[id];
                }
                finally
                {
                    Monitor.Exit(this._refs);
                }
            }
            set
            {
                try
                {
                    Monitor.Enter(this._refs);
                    int id = Thread.CurrentThread.ManagedThreadId;
                    if (this._refs.ContainsKey(id))
                    {
                        this._refs[id] = value;
                    }
                    else
                    {
                        this._refs.Add(id, value);
                    }
                }
                finally
                {
                    Monitor.Exit(this._refs);
                }
            }
        }

        /// <summary>
        /// Disposes of a Thread Safe reference
        /// </summary>
        /// <remarks>
        /// Does not take any dispose actions on the references it holds, it will drop those so the GC can collect them as desired.  This also avoids any unintended consequences of a dispose on one thread causing strange behaviour on another
        /// </remarks>
        public void Dispose()
        {
            try
            {
                Monitor.Enter(this._refs);
                this._refs.Clear();
            }
            finally
            {
                Monitor.Exit(this._refs);
            }
        }
    }

    class ThreadIsolatedValue<T>
        : IDisposable
        where T : struct
    {
        private Dictionary<int, T> _refs = new Dictionary<int, T>();
        private Func<T> _init;

        /// <summary>
        /// Creates a new ThreadSafeValue where the initial value of the struct on each thread is default
        /// </summary>
        public ThreadIsolatedValue() { }

        /// <summary>
        /// Creates a new ThreadSafeValue where the initial value of the struct on each thread is generated by the given initialiser function
        /// </summary>
        /// <param name="init">Initialiser Function</param>
        public ThreadIsolatedValue(Func<T> init)
        {
            this._init = init;
        }

        /// <summary>
        /// Gets the initialiser function
        /// </summary>
        public Func<T> Initialiser
        {
            get
            {
                return this._init;
            }
        }

        /// <summary>
        /// Gets/Sets the value for the current thread
        /// </summary>
        public T Value
        {
            get
            {
                try
                {
                    Monitor.Enter(this._refs);
                    int id = Thread.CurrentThread.ManagedThreadId;
                    if (!this._refs.ContainsKey(id))
                    {
                        T value = (this._init != null) ? this._init() : default(T);
                        this._refs.Add(id, value);
                    }
                    return this._refs[id];
                }
                finally
                {
                    Monitor.Exit(this._refs);
                }
            }
            set
            {
                try
                {
                    Monitor.Enter(this._refs);
                    int id = Thread.CurrentThread.ManagedThreadId;
                    if (this._refs.ContainsKey(id))
                    {
                        this._refs[id] = value;
                    }
                    else
                    {
                        this._refs.Add(id, value);
                    }
                }
                finally
                {
                    Monitor.Exit(this._refs);
                }
            }
        }

        public void Dispose()
        {
            try
            {
                Monitor.Enter(this._refs);
                this._refs.Clear();
            }
            finally
            {
                Monitor.Exit(this._refs);
            }
        }
    }
}
